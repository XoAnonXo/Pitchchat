import type { Express, Request, Response } from "express";
import { Readable } from "node:stream";
import type { ReadableStream as WebReadableStream } from "stream/web";

type ProxyConfig = {
  origin: string;
};

const DEFAULT_PROXY_PATH_PREFIXES = ["/investor-questions", "/sitemaps", "/_next"];
const DEFAULT_PROXY_EXACT_PATHS = ["/sitemap.xml", "/robots.txt"];

const HOP_BY_HOP_RESPONSE_HEADERS = new Set([
  "connection",
  "keep-alive",
  "proxy-authenticate",
  "proxy-authorization",
  "te",
  "trailers",
  "transfer-encoding",
  "upgrade",
]);

const HOP_BY_HOP_REQUEST_HEADERS = new Set([
  "connection",
  "keep-alive",
  "proxy-authenticate",
  "proxy-authorization",
  "te",
  "trailers",
  "transfer-encoding",
  "upgrade",
  "host",
  // Express/Node will handle content length for us.
  "content-length",
]);

function normalizeOrigin(value: string) {
  return value.replace(/\/$/, "");
}

function buildUpstreamHeaders(req: Request) {
  const headers: Record<string, string> = {};

  for (const [key, value] of Object.entries(req.headers)) {
    if (!value) continue;
    const normalizedKey = key.toLowerCase();
    if (HOP_BY_HOP_REQUEST_HEADERS.has(normalizedKey)) continue;

    if (Array.isArray(value)) {
      headers[normalizedKey] = value.join(",");
      continue;
    }

    headers[normalizedKey] = value;
  }

  // Avoid proxy compression edge cases (mismatched bytes/header).
  headers["accept-encoding"] = "identity";

  const originalHost = req.get("host");
  if (originalHost) {
    headers["x-forwarded-host"] = originalHost;
  }

  const forwardedProto = req.get("x-forwarded-proto");
  headers["x-forwarded-proto"] = forwardedProto ?? req.protocol ?? "https";

  return headers;
}

function rewriteLocationHeader(location: string, config: ProxyConfig) {
  try {
    // Rewrite absolute redirects back to main domain by stripping upstream origin.
    if (location.startsWith(config.origin)) {
      const url = new URL(location);
      return `${url.pathname}${url.search}${url.hash}`;
    }
  } catch {
    // Ignore parse errors and fall back to original header.
  }

  return location;
}

async function proxyGetRequest(config: ProxyConfig, req: Request, res: Response) {
  const targetUrl = `${config.origin}${req.originalUrl}`;
  const upstream = await fetch(targetUrl, {
    method: req.method,
    headers: buildUpstreamHeaders(req),
    redirect: "manual",
  });

  res.status(upstream.status);

  upstream.headers.forEach((value, key) => {
    const normalizedKey = key.toLowerCase();
    if (HOP_BY_HOP_RESPONSE_HEADERS.has(normalizedKey)) return;

    if (normalizedKey === "location") {
      res.setHeader(key, rewriteLocationHeader(value, config));
      return;
    }

    res.setHeader(key, value);
  });

  if (!upstream.body) {
    res.end();
    return;
  }

  Readable.fromWeb(upstream.body as unknown as WebReadableStream).pipe(res);
}

export function registerPseoProxy(app: Express) {
  const origin = process.env.PSEO_ORIGIN;
  if (!origin) {
    return;
  }

  const config: ProxyConfig = {
    origin: normalizeOrigin(origin),
  };

  const handler = async (req: Request, res: Response) => {
    if (req.method !== "GET" && req.method !== "HEAD") {
      res.status(405).send("Method Not Allowed");
      return;
    }

    try {
      await proxyGetRequest(config, req, res);
    } catch (error) {
      console.error("pSEO proxy error:", error);
      res.status(502).send("Bad Gateway");
    }
  };

  // Prefix routes (subdirectory + Next asset path + segmented sitemaps)
  for (const prefix of DEFAULT_PROXY_PATH_PREFIXES) {
    app.use(prefix, handler);
  }

  // Root-level SEO endpoints generated by the pSEO Next app.
  for (const pathname of DEFAULT_PROXY_EXACT_PATHS) {
    app.get(pathname, handler);
    app.head(pathname, handler);
  }
}

